<h1>SQLite怎么实现原子性</h1>
###1.0 简介
事务性数据库一个重要的性质就是原子性. 原子性意味着同一个事务内的操作, 要么全部生效, 要么全部不生效. 在保证原子性的情况下, 对数据库文件的不同修改就好像能够"同时发生"一样. 实际上, 硬件在处理多个写入操作时, 是将它们序列化完成的, 并不是"同时发生". 但是SQLite实现了原子性, 使得这些操作在逻辑上能够被视为"同时发生".

SQLite在处理事务时, 即使遇到了诸如系统崩溃甚至是突然断电的这种情况, 也能维持其原子性. 

本文就描述SQLite怎么实现的原子性. 

本文描述的技术只是SQLite在"rollback mode"下所使用的, 而在另一种模式, "WAL mode"下使用的技术则不同. 关于"WAL mode"下的技术, 请看[write-ahead log documentation](http://www.sqlite.org/wal.html).

###2.0 对硬件的假设
我们假设硬盘写入的最小单位为"区(sector)". 诸如只修改部分区的内容的操作, 是不被允许的. 如果你真的只想要修改区上部分内容, 你也得读出整个区的内容, 然后做出修改, 再整个写回到硬盘.

在传统硬盘中, "区"的限制是同时针对读和写操作的. 而在闪存中, 读的最小单位通常比写的最小单位小得多. SQLite只考虑对写入操作的最小单位限制, 本文中所说的"区", 都只针对写操作.

在SQLite3.3.14版本之前, 区的大小都被设置为512bytes. 虽然你可以修改代码来扩大这个值, 但是我们并没有对更大的区值进行测试. 用512bytes作为默认值是有原因的, 因为大多数硬盘都在内部使用512bytes作为一个扇区大小. 但是最近以4096bytes作为扇区大小的硬盘越来越多, 所以SQLite中区的限制也应该增大. 从SQLite3.3.14起, 我们在OS层中增加了一个函数用来查找操作系统的扇区大小. 但是现在这个函数依旧返回的只是一个512bytes的固定值, 因为我们没有发现一个统一的方法, 能够同时在unix和windows下查询到扇区大小. 但是你能够为你的设备复写这个函数, 以选取一个最合适的"区值".

SQLite假设对区的写操作不是原子性的. 并且SQLite假设它是线性的. 线性的意思是我们假设操作系统从区的一头开始, 按照bytes的顺序逐一写入. 开始的位置可以是区两头中的任意一头. 如果在写入的过程中发生了断电等情况, 那么这个区的一部分内容就会出现问题. SQLite另一个重要假设是, 如果出现了这种情况, 那么区的两头结尾的两个byte的值, 一定有一个被改变了. 所以我们预想操作系统不会从区的中间开始写数据, 虽然不知道是不是所有操作系统都满足我们的假设, 但是我们看来这样假设是合理的.

上一段说了我们并不假设磁盘写入是原子性的. 在SQLite3.5.0后, 我们抽象出了一层新结构, 虚拟文件系统VFS(virtual file system). 只有通过VFS, SQLite才能和操作系统打交道. 在新的VFS接口中, 有一个叫xDeviceCharacteristic的函数. 这个函数会询问操作系统, 看它是否满足某些性质. 如果操作系统的区写入操作是原子性的, 这个函数将能发现, 此时SQLite应该利用这一性质进行优化. 但是在实际中, 不管是unix还是windows, 其区写入操作都不是原子性的, 所以这项优化也被我们直接忽略了. 

SQLite假设操作系统会有写入缓冲, 并且在写入完成时, 缓冲区的内容不一定被写入到了硬盘盘中. 进一步的, SQLite假设操作系统会对写入操作重排序. 因此, SQLite会执行"flush"和"fsync"操作, 且假设这两个操作只有当硬盘同步结束后, 才会返回. 然而在某些版本的windows和unix上, flush和fsync操作是无用的. 这增大了SQLite出现错误的可能性. 对于这种情况, 我们也无能为力. 

SQLite假设随着数据库文件的增大, 新增加的空间包含原来的信息, 这些信息被当作垃圾, 随后, 这些垃圾信息将被新写入的信息覆盖. 换句话说, SQLite假设先增加文件的大小, 后修改其内容. 这是一个悲观的假设, 因此SQLite需要做额外的工作, 来保证数据库不会出现错误, 比如当操作系统修改了文件大小, 却还未修改其内容, 然后出现断电时. xDeviceCharacteristics函数会检查操作系统是否是先修改文件内容再修改文件大小. (这个性质在代码中被设置为SQLITE_IOCAP_SAFE_APPEND.) 当xDeviceCharacteristics 检测到操作系统确实是先修改文件内容, 在修改文件大小时, SQLite就可以略去一些多余的操作, 以此来增加硬盘I/O速率. 然而在实际的实现中, 不管是对windows还是unix, 我们都没做出这样的乐观假设.

SQLite假设从进程的角度来看, 删除文件是原子性的. 这意味着, 如果SQLite请求删除操作, 而此时断电了, 那么电力恢复时, 那个文件要么被全部删除了, 要么毫无影响. SQLite假设不会出现文件出现"被部分删除"的情况. 

SQLite假设bit反转的情况由各种物理原因, 以及操作系统bug等因素造成, 这应该是操作系统以及底层硬件的责任. 因此SQLite不会对这些情况做任何检测和处理.

默认的, SQLite假设当通过系统调用在对文件的某个区间进行写操作时, 不会对这个区间外的其他信息有任何影响, 即使是出现了系统崩溃或者断电等情况. 我们称之为[powersafe overwrite](http://www.sqlite.org/psow.html). 在3.7.9版本前, SQLite并没有做出这种乐观假设. 但是随着硬盘的标准扇区从512bytes扩大到了4096bytes, 我们需要做出这个乐观假设, 来提高I/O速率. 但是这个假设可以在编译甚至运行时期给去除, 详细请看[powersafe overwrite](http://www.sqlite.org/psow.html).