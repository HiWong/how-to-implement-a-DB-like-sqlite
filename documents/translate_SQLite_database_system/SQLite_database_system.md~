<h1>第3章.存储结构</h1>
###学习目的:
读完本章内容后, 你会知道:

+   SQLite数据库文件的结构
+  各种记录文件的结构及格式
+ SQLite中page的概念及其作用
+ 数据库怎么实现平台无关化

###本章大纲
本章描述SQLite底层的文件结构及格式. SQLite数据库文件被分割成了固定大小的page, 用于存储"B/B+tree pages", "freelist pages"和其他page结构. 在默认的journaling mode中, 记录文件在改动前将原本的"page"给记录下来; 而在WAL mode中, 记录文件存储的是改动后的"page". 本章将讨论这些文件的命名规则及内部结构.

###3.1 数据库命名规则
SQLite中, 数据库被存储于一个单独的大文件中, 称之为database file. 当一个应用试图用sqlite3_open API打开某个数据库时,  实际上就是给这个函数一个database file的名字作为参数. 这个文件名字可以是相对路径或者绝对路径. 任何能被系统接受的文件名都可以. 但是这里有两个例外:

+  如果被传入的文件名为空或者全部为空格, SQLite会创建一个新的临时文件. 
+ 如果给定的文件名是":memory", SQLite将会在内存中建立一个数据库. 

在上述两种情况中, 被建立的数据库都是临时的, 当应用关闭数据库时, 它们将不复存在.

<b>database file命名:</b> 以.db结尾, 用于区分.
<b>URI命名:</b> 始于SQLite3.7.7, 支持用URI命名方式. URI应该开始于file:. 其他信息请访问[URI命名规则](http://www.sqlite.org/uri.html)
<b>SQLite中的临时文件:</b> SQLite使用了许多种临时文件, 比如rollback journal, statement journal, multidatabase master journal, transient index, transient database.
<b>临时文件命名:</b> SQLite随机生成每个临时文件名. 这些名字以etilqs_开头, 接着是16个字母或数字, 没有后缀名. 你可以修改宏定义SQLITE_TEMP_FILE_PREFIX来修改这些文件的前缀. 这些临时文件可能存储在(1)/var/tmp (2)/usr/tmp (3)/tmp中. 你可以修改TMPDIR环境变量来指定存储路径. 如果系统在关闭这些临时文件前崩溃了, 那么它们可能被保留下来.

不管以何种方式打开一个数据库, 我们都将被打开的数据库称作main database. SQLite还为每个"数据库链接"维护着一个temp database. 如图3.1. 当一个应用打开不同的链接时, 每个链接会有自己的临时文件. SQLite会在链接关闭的时候删除这些临时文件. main database和temp database文件的结构是一致的. 
![Pic3.1](/home/qw4990/桌面/SQLITE_BOOK/Pic3.1.png)
SQLite中有两个不同但相互关联的概念. 通过使用attach指令, 你能以一个不同的名字, 关联一个数据库文件到你的链接上. 举个例子, 指令 attach /home/sibsankar/MyDB as DB1 使得MyDB这个数据库文件被链接打开. 随后你就能使用Select * from DB1.table1对这个数据库进行查找. 

<b>链接的疑惑:</b> sqlite3_open API使用数据库文件名打开一个链接. 这个链接能够连接到main database和temp database. ===
<br>

###3.2 数据库文件结构
除了in-memory database, SQLite将整个数据库都存储于一个文件中. 在其生命周期中, 文件大小不断的改变. 操作系统将数据库文件视为普通的文件, 但是并不解释其文件内容. 其实现了对数据库文件任意bytes间的read/write甚至sync操作. 在剩下的内容中, 我将阐述SQLite怎样将数据库文件按页(page)的方式进行组织.

####3.2.1 Page抽象
为了方便空间管理, SQLite将database file按固定大小的页(page)组织. 因此, 一个database file的大小总是page大小的倍数. Page被从1开始编号. 0号page被视作NULL. 这些page被线性存储, 如图3.2. 你可以将database file视作一连串的page. 而page的编号则用于访问这些page.
![Pic3.2](/home/qw4990/桌面/SQLITE_BOOK/Pic3.2.png)

####3.2.2 Page大小
默认的Page大小是1024bytes, 但是在编译时期可以进行设置. Page大小必须是2的次方, 并且大于等于512(2^9), 小于等于65536(2^16). 这个最大限制是因为Page大小被存储为一个2bytes的short型整数. 一个database file最多能有2^31 - 1页page; 这个数字被写在了宏PAGER_MAX_PGNP中. 因此SQLite的数据库最大能到140TB(2^16 * 2^31 = 2^47). 除此之外, 最大限制也受制于操作系统.
 
####3.2.3 Page类型
根据Page的用途, 它们被分为四类: free, tree, pointer-map, lock-byte. Free pages是暂未被使用的. Tree pages又能被细分为leaf, internal和overflow类型. B+Tree的internal page存储着树上的跳转信息, leaf page存着数据. 如果某条信息太大, leaf page存不下来, 那么存不下的信息将会被保存到一个或多个overflow page上.

####3.2.5 freelist格式
未被使用的pages被组织在文件头32位偏移处. 而free page的总数被存在36位偏移处. Freelist的组织如图3.5. Freelist有两种子类型: trunk pages和leaf pages. trunk pages中
存储了leaf pages的编号.
![Pic3.5](/home/qw4990/桌面/SQLITE_BOOK/Pic3.5.png)
Trunk page的结构如下: (1)4-bytes的空间存储下一个trunk page的编号; (2)4-bytes的空间存该trunk page内的leaf page编号个数; (3)0或者多个4-bytes的leaf page编号.

当某page变成free状态时, 它并不会被操作系统释放掉, 而是被添加到Freelist中. 当你向SQLite中添加新数据时, SQLite会从freelist中拿出free page来存储新内容. 只有当freelist为空时, SQLite才会向操作系统申请新的空间. 

有些时候, freelist中的page可能会过多. 此时你可以运行VACUUM指令来整理过多的空间. SQLite此时会将freelist过多的页码让操作系统释放, 以减少database file的大小. 

<b>Freelist 整理:</b> 当你使用VACUUM指令来整理freelist时, SQLite会将整个database拷贝成一个临时文件, 用于事务保护.
<br>

###3.3 Journal File 结构
SQLite使用三种journal file, 分别是rollback journal, statement journal, master journal. (它们被称为legacy journals. 在SQLite 3.7.0版本后, SQLite团队引入了WAL journaling模式. Database file能够处于这两种模式之一.) 我将在接下来的三章介绍legacy journals, 而关于WAL的内容, 将会被放到10.17节.
<br>

####3.3.1 Rollback journal
SQLite会对每个数据库维护一个rollback journal file. (In-memory database不需要). Rollback journal file总是和其database file在同一个文件夹下. 其名字为database file名字加上"-journal". journal文件在默认模式下只是临时文件, SQLite会在每次write-transaction的时候创建它们, 并在事务完成时删除. 

SQLite会将rollback journal file分成多个变长度的log segment, 如图3.6. 每段log segment开始于segment header, 接着是一个或多个log records.
![Pic3.6](/home/qw4990/桌面/SQLITE_BOOK/Pic3.6.png)

####3.3.1.1 Segment header结构
Segment header结构如图3.7. Segment header开始与8个特殊的bytes: 0xD9, 0xD5, 0x05, 0xF9, 0x20, 0xA1, 0x63, 0xD7. 我们将这个序列称为magic number. 这个序列是被随机选取的, 只是被用来做一点常规检查, 并没有什么卵用. Number of records (简称为nRec) 记录有多少个log segment, nRec在异步事务处理时会被初始化为-1, 在普通事务处理时被初始化为0. Random number被用来计算checksum. Initial database page count记录原database中一共有多少pages. Sector size表示database file所在磁盘扇区大小. Page size表示page大小. 剩下的空间留作备用. 

![Pic3.7](/home/qw4990/桌面/SQLITE_BOOK/Pic3.7.png)

<b>Sector size检测:</b> 其检测需要操作系统支持, 如果不能, 则默认为512bytes. SQLite认为操作系统只能以Sector为最小单位进行读写操作.

Rollback journal file通常只含有一个log segment. 但是某些情况下, 会存在多segment的文件, 此时SQLite会多次对segment header进行读写(我将在5.4.1.3讨论这情况). 每次进行segment header读写时, 都会以sector为单位. 

<b>Journal file保留: </b>默认的模式下, SQLite会在事务完成后删除journal files. 但是你能通过prama journal_mode指令来保留它们. journal_mode有DELETE, PERSIST, TRUNCATE三种, 默认是DELETE. 还有几种其他的journal_mode我会在之后进行介绍. 如果应用使用了exclusive locking 模式 (pragma locking_mode = exclusive), SQLite会创建并保留Journal file直到应用取消这个锁. 

<b>Journal的维护: </b>rollback journal只有当其含有合法的segment header时才有效. 无效的journal将不会被用于事务保护. 

<b>异步事务: </b>SQLite支持比普通事务更快的异步事务. 异步事务处理期间, SQLite不会刷新journal和database file, 并且journal file只会有一个log segment. 此时nRec会为-1. SQLite不建议使用异步事务, 但是你能够执行pragma指令来开启. 

####3.3.1.2 Log record结构
非SELECT语句都会产生log records. 在修改任何page之前, 原page的内容都会被写入journal的新log record中. 图3.8展示了一个log record的结构. 它包含了一个4-bytes的checksum. 这个checksum涵盖了page number到page content的内容. segment header中的random number被作为计算checksum的键值. 这个Random number非常重要, 如果某条log recorder的垃圾数据刚好来自同页的另外一份journal file, 那么其checksum就刚好是正确的. 而对不同的journal file使用不同的rondom number作为键值, 则能将这个风险最小化. 
![Pic3.8](/home/qw4990/桌面/SQLITE_BOOK/Pic3.8.png)

####3.3.2 Statement journal

####3.3.3 Multi-database transaction journal 和 master journal

####总结
SQLite把所有的数据信息存储到一个大文件内 (database file). 但同时也支持临时和in-memory数据库, 它们将会在应用打开时被建立, 并在应用关闭时被删除. 

每个database file都是一个固定页大小组织的文件. 逻辑上, database file就是一连串的pages. 默认的page大小是1024, 但是能被设置在512到65536之间, 同时其大小必须为2的次方. database file最多能包含2^31 - 2页. Pages被分为4种: free, tree, lock-byte, pointer-map. Tree page能被细分为internal, leaf, overflow. 

第一个page被成为anchor page. database file的前100bytes包含了整个数据库的一些基本信息, 比如page size等. 所有的free pages都被以rooted trunked tree结构组织. 

SQLite使用三种journal files: rollback, statement, master. rollback和master journal和database file在同个文件夹下, 而statement通常在一个临时目录, 比如/tmp. rollback journal存储变长的log records. 而master journal存储多数据库事务下所有rollback journal的名称. statement journal则为每条单独的insert/update/delete语句提供记录. 

<br><br><br><br><br><br><br><br><br><br><br><br>

<h1>第4章.事务管理</h1>
###学习目的:
读完本章内容后, 你会知道:

+   SQLite怎么实现ACID
+  SQLite管理lock的方式
+  SQLite怎么避免deadlocks
+  SQLite怎么实现journaling protocols
+ SQLite怎么记录savepoint

###本章大纲
DBMS的主要职责之一就是帮助用户维护database. DBMS能够在多用户同时操作的情况下对database进行保护, 以及在事务失败时进行回滚和恢复. 为了实现这些功能, SQLite以事务为单位执行操作. SQLite在实现ACID时会依赖操作系统和journals. 你可以认为SQLite只支持 flat transaction, 不支持nesting transaction. 本章我会介绍SQLite怎么实现ACID, 下一章我会介绍SQLite中进行事务管理的pager层.

###4.1 事务类型
几乎所有的DBMS都使用locking mechanisms进行并发控制, 使用journals来保存恢复信息. 在database被修改之前, DBMS将一些日志信息写入journals. DBMS会保证这些日志信息被完整的存储了之后, 才进行database修改. 当transaction失败后, DBMS能从日志文件中读取足够的信息来恢复. 在SQLite中, lock方式和log方式都取决于transaction的类型. 我将会在本章对这些类型进行介绍.

###4.1.1 System transaction
SQLite将每条语句放在transaction内执行, 支持读和写 transaction. 上层应用只能通过读写transaction读取数据, 只能通过写transaction写入数据到database. 在执行SQL语句时, 不必显式的让SQLite为其包裹transaction, SQLite会自动进行. 这就是autocommit模式. 这样形成的transaction称之为system or auto or implicit transactions. 对于SELECT语句,  SQLite自动将其置入一个read transaction内执行. 对于non-SELECT语句, SQLite先创建一个read transaction, 然后将其转换为一个write transaction. 每个transaction将会在执行后被自动提交. 对于上层应用而言, 它并不知道transaction的存在. 

应用能并发的执行SELECT语句, 但是不能并发执行non-SELECT语句. non-SELECT会被原子性的执行, SQLite会为多个non-SELECT维护mutex. 而SELECT语句则不会被原子性执行. 

###4.1.2 User transaction
默认的autocommit模式对某些应用来说可能会有很昂贵的代价, 特别是对那些写敏感的操作. 因为SQLite对每条non-SELECT语句都会要求重打开, 写入, 关闭journal files. 除此之外, 还会有并发控制带来的额外负担, 比如需要对database file申请和释放lock. 为了避免上述开销被重复, 用户可以开启一个user transactiong. 可以把多条SQL语句写在"BEGIN TRANSACTION"和"COMMIT [or ROLLBACK] TRANSACTION"之间. 

###4.1.3 Savepoint
SQLite为user transaction提供了savepoint. 应用能在user transaction内或外执行savepoint指令. Savepoint是transaction内的点, 它表示当前transaction的一种状态. 一个transaction能包含多个savepoint. 当transaction失败时, 我们能回滚到某个savepoint.

###4.1.4 Statement subtransaction


###4.2 Lock management
多并发的系统需要有一套同步机制来隔离并发transaction相互的影响. 隔离性这个词经常被用在并发控制, 序列化和锁机制中. 对于事务隔离, 有许多概念, 比如read commited, cursor stable, repeatable read, serializable. Serializable是最严格的隔离等级, 而SQLite实现了它.

SQLite使用了lock机制来实现Serializable, 并不使用进程间的共享内存. SQLite使用的是操作系统提供的file lock. 

SQLite允许同时对同一个database file进行任意数量的read transaction, 但是同一时刻只能有一个write transaction. SQLite的lock机制非常简单, 它只对database file进行lock, 而不是对数据库中某一行或者列进行lock. 在下面的内容中, 我将会叙述SQLite如何管理lock.

###4.2.1 Lock类型以及其相容性
从某个transaction的角度来看, 一个database file可能有下面5种类型. 你应该清楚它们是SQLite实现的, 而不是操作系统提供的. 

+ NOLOCK: Transaction没有取得任何类型的锁, 它不能进行读写操作. NOLOCK是transaction被建立时的初始状态. 

+ SHARDED: 这个锁只允许读操作. 任何数量的transaction能够同时取得该锁. 该锁不运行写操作. 

+ EXCLUSIVE: 这是唯一能够允许写操作的lock, 同时刻在database file上只能有一把EXCLUSIVE lcok. 其他lock不允许与该lock共存.

+ RESERVED: 该锁运行读取操作. 但是和SHARED不同, RESERVED lock暗示其他transaction它将要进行写操作. 同时刻只能有一把RESERVED锁, 且能够与其他SHARED lock共存. 其他transaction在此期间能够申请新SHARED locks.

+ PENDING: 该锁允许读操作. PENDING lcok意味着这个transaction马上很快将会进行写入操作. 它时取得EXCLUSIVE之前的一个过渡lock. Transaction处于这个状态时其实实在等待其他SHARED lock被释放. 同时刻只能有一个PENDING lock, 且它能与其他SHARED lock共存, 但是不允许申请新的SHARED lock.

SQLite锁的共存性如下图:
![Pic4.1](/home/qw4990/桌面/SQLITE_BOOK/Pic4.1.png)

<b>讨论: </b>对于一般的数据库来说, 起码需要EXCLUSIVE lock, 其他的locks只是用来进行并发控制. 如果只含有EXCLUSIVE lock, transaction将会被序列化的执行. 有了SHARED 和 EXCLUSIVE locks, 则能够对读取操作进行并发. 实际中, transaction在SHARED lock下, 读取数据, 修改, 然后申请EXCLUSIVE lock来写回数据. 如果有两个这样的transaction同时执行, 那么就可能会引发死锁. 而RESERVED 和 PENDING就是用来预防死锁形成. 这两个锁同时也能帮助预防写者饿死(writer starvation). 

####4.2.2 Lock申请协议
Transaction在读写操作前申请合适的锁, 来保证多transaction之间不会产生冲突. Pager层的责任之一就是为transaction生成适当的locks.

Transaction开始的时候处于NOLOCK. 在读取前, 它会申请一个SHARED lock. 此时它就成为了read transaction, 能够读取database file中的任何pages. 在改变database file之前, 它会申请一个RESERVED lock. 此时它变成了write transaction, 但是此时它的影响对其他transaction来说是不可见的. 当得到RESERVED lock后, transaction就能修改内存中的page. 在将修改内容写回到文件之前, 它需要申请EXCLUSIVE lock. 此时它将成为一个full write transaction, 在将修改内容写回到文件后, 其修改就立即对其他可见了.

Locking状态图如下. 注意Pager不能取得PENDING lcok, PENDING lock只是取得EXCLUSIVE前的一个临时状态.
![Pic4.2](/home/qw4990/桌面/SQLITE_BOOK/Pic4.2.png)

对于一般的read transaction, 状态通常是从NOLOCK到SHARED再回到NOLOCK. 对于write transaction而言, 通常是NOLOCK到SHARED到RESERVED最后到EXCLUSIVE, 再回到NOLOCK. SHARED直接到PENDING的情况发生在有journal需要回滚时.

在lock管理时, 实现了两个函数, sqlite3OsLock, sqlite3OsUnlock 用来申请和释放locks. 它们被定义在os.h文件内. 这两个函数将被Pager层调用. 当如database被关闭时, Pager会释放掉所有的锁. 我会在4.2.7中继续讨论这两个函数. 

###4.2.3 显式locking

###4.2.4 Deadlock和starvation
尽管lock机制解决了并发性问题, 但是它又带来了其他的问题. 假象有2个transaction对同一个database file持有SHARED lock. 同时它们都想申请RESERVED lock. 现在其中一个得到了RESERVED lock, 而另一个则继续等待. 处于RESERVED的, 现在申请了EXCLUSIVE lock, 于是它开始等待另一个transaction释放其SHARED lock, 但此时另外一个却在等待RESERVED lock. 于是引发了一个deadlock.

Deadlock是一个头疼的问题, 这里有两种方法可以消除deadlock.(1)预防, (2)检测和消除. SQLite能预防deadlock, SQLite采用非阻塞式的取锁方式 - 申请lock时, 要么得到一个lock, 要么得到一个错误代码, 而不会被阻塞起来等待. 当某次取锁失败后, transaction会进行有限次的重新尝试. 如果所有尝试都失败了, 将会返回SQLITE_BUSY错误. 由于上述方式的预防, 系统中几乎不会存在deadlock. 

####4.2.5 Linux lock primitives
SQLite的locks通过操作系统的文件锁实现. Linux实现了两种native lock, read lock和write lock. 它们可以被作用在文件上一段连续的区域上. write lock不能和其他lock共存, 包括read lock和write lock. 但是read lock 和 write lock 能共存在同一文件的不同区域. 一个进程在文件某个区域只能申请一种类型的lock. 如果在已上锁的区域上申请新的lock, 那新的lock将会将原lock覆盖掉. 

<b>注意: </b>文件上的lock并不是文件内容的一部分, 它们只是内核维护的一种数据结构. 

####4.2.6 SQLite lock实现
SQLite通过操作系统提供的函数实现其自己的locking结构. 由于linux只有read lock, write lock两种native lock, 因此SQLite通过锁住不同的文件位置的方法, 来实现其4种lock. 它通过fcntl来申请和释放lock. 本章讨论操作系统locks到SQLite locks的转换方法. 

+ SHARED lock 实现于在database file的整个shared区间上设置一把read lock. 

+ EXCLUSIVE lock 实现于对整个database file的shared区间设置一把write lock.

+ RESERVED lock 实现于在某个特定的byte上设置一把write lock, 这个byte被称为reserved lock bytes.

+ PENDING lock 实现于在某个特定的byte上设置一把write lock, 这个特定的byte不同于RESERVED中的, 且在SHARED的区间外.

下图演示了上述方法. SQLite预留了510bytes作为shared的上锁区间, 这个值被宏SHARED_SIZE定义. 区间开始于宏SHARED_FIRST. 宏PENDING_BYTE (=0x40000000, 是1GB后的第一个bytes) 则是PENDING lock的默认上锁位置. RESERVED_BYTE被设计在PENDING_BYTE后一个byte. 而SHARED_FIRST被设置在PENDING_BYTE后两个. 所有的上锁区间都能适配所有大小的page, 即使是最小512bytes的page. 这些宏被定义在os.h中.
![Pic4.3](/home/qw4990/桌面/SQLITE_BOOK/Pic4.3.png) 

####4.2.6.1 SQLite lock到native lock
下面几段话叙述了SQLite怎么对database file上锁.

+ 为了取得SHARED lock, 进程先对PENDING_BYTE取得一个read lock, 以确保没有PENDING lcok. 如果成功, SHARED lock自己的区间将会被上一个read lock, 接着PENDING_BYTE的read lock将会被释放. 

+ 进程只会在SHARED的状态下去申请RESERVED lock. 进程会直接在RESERVED_BYTE加上write lock. 但是它并不是释放SHARED lock (这个举措用来保证其他进程在此间其不能得到EXCLUSIVE lock).

+ 进程或许会从SHARED直接想要取得PENDING. 为此, 它先取得PENDING_BYTE的write lock (此举用来阻止新SHARED lock). 此时它并不释放SHARED lock (这个举措用来保证其他进程在此间其不能得到EXCLUSIVE lock).
<b>注意: </b>进程能跳过RESERVED直接取得PENDING lock. 这个性质被用于SQLite回滚journal. 

+ 进程取得PENDING lock后或许会申请EXCLUSIVE lock. 首先先在shared区间加上write lock. 因为所有的SQLite lock都会在shared区间上申请read lock, 所以此举能够保证此时没有其他的锁. 

下图是上述步骤的转换图. PENDING lock 和 EXCLUSIVE lock有一点小不同, 它们可能会也可能不会对RESERVED_BYTE有write lock, 这取决于SQLite怎么设置这些locks.
![Pic4.4](/home/qw4990/桌面/SQLITE_BOOK/Pic4.4.png)


####4.2.6.2 Native locks的工程性问题
上述lock机制有两个工程上的问题. 第一个问题的是Linux native lock的性质造成. 第二个则是SQLite自身的问题. Native lock是以进程为单位分配的, 而SQLite locks是以线程为单位分配(如下图). 图中, 进程1有两个线程: 线程1有1个transaction, 线程2有两个, 它们通过三个不同的连接访问database file.进程2有一个transaction. 四个并发的transaction中, 三个有SHARED lock, 一个有RESERVED lock. Transaction对操作系统是透明的, 操作系统只能看到进程. 我们需要有一个映射用来将transaction中的SQLite lock和进程中的native lock对应起来. 

如果一个进程只打开一个连接, 那么进程和transaction是同步的, 如进程2的情况. 当进程通过不同的连接并发处理多个transaction时, 情况就复杂了, 如进程1的情况. 什么样的native lock才能对应进程1中的3个transaction呢? 我将在下面个两个章节中处理这两个问题. 现在唯一值得庆幸的是, 一个连接最多打开一个database file. (也就是在处理transaction时, 进程打开database file, 执行transaction, 然后关闭database file; 下一个transaction来临时, 再重新打开)
![Pic4.5](/home/qw4990/桌面/SQLITE_BOOK/Pic4.5.png)

####4.2.6.3 Linux系统问题
SQLite使用了POSIX协议的locking结构, 并且使用fcntl来申请和释放lock. 正如之前所说, locks只是操作系统维护在内存中的一种数据结构. 值得一提的是linux的lock是针对inode进行维护的, 而不是文件名. 在Linux中,  使用软或硬连接能将不同的文件名指向相同的inode, 这会对native lock造成某些奇怪的影响. 第二点需要注意的是虽然locks是通过fcntl和file descriptor进行上锁, 但是它们两者之间没有什么联系, 只和inode有关系. 如果一个进程对某个文件在相同的区域用两个不同的file descriptor进行上锁, 那么第二个lock将会覆盖掉第一个 (这两次操作来自同一个进程不同的线程).

下面通过几个例子来演示一下上述问题. 假设file1和file2是两个有不同文件名的相同文件(指向不同的inode). 假设某进程打开了它们:
int fd1 = open("file1", ...);
int fd2 = open("file2", ...);
假设线程1通过fd1取得了一个read lock; 线程2通过fd2在相同位置取得了一个write lock, 此时之前的read lock就被覆盖了, 因为两个lock都来自同一个进程, 且在相同位置. 

这意味着如一个进程多线程的打开了database file, 并执行不同的操作, 那么它们之间会相互的影响. 于是我们不能简单的使用native lock来进行并发控制. 

<b>线程控制内容暂时省略...</b>

####4.6.2.4 多线程应用

####4.2.7 Lock APIs
Lock机制被实现在两个函数中, sqlite3OsLock和sqlite3OsUnlock. 本章我将描述它们的算法步骤.

####4.2.7.1 sqlite3OsLock
sqlite3OsLock的完整定义为int sqlite3OsLock(unixFile *id, int locktype). 其中id是SQLite定义的file descriptor. 对于unix, 这个函数被实现在os_unix.c中. 你应该注意到locktype不能为PENDING.